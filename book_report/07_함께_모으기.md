<img width="300" alt="07-1" src="https://github.com/ciocio97/today_i_learned/assets/80025242/84349b1b-5fcc-43f0-95ad-1d7e53734eeb">

관점을 잘 드러나는 코드가 좋은 코드다.

<br/>

# 객체 지향 설계의 세 가지 관점

#### 개념 관점

* 도메인 내 개념과 개념 사이의 관계
  * 도메인: 사용자들이 관심을 갖고 있는 특정 분야나 주제
* **실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심**

#### 명세 관점

* 도메인을 벗어난 개발자영역의 소프트웨어 초점
* 객체들의 책임에 초점 ( = 인터페이스 )
* **인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙**
  * → 프론트 개발만 하면 이해하기 쉽지 않을 것같아요.

<img width="600" alt="07-2" src="https://github.com/ciocio97/today_i_learned/assets/80025242/8dd66118-99ce-4f41-ab3c-cec459950a99">
<p></p>

  
#### 구현 관점

실제 작업 수행 코드 ( = 객체들이 책임을 수행하는 데 필요한 동작 코드 )

#### 개념 → 명세 → 구현 순서로 개발하라? ❌
  
* 설계를 처음부터 완벽하게 하기는 쉽지 않습니다.
  
  설계를하다보면, 혹은 유지보수하거나 개발 초기  
  구현부가 다양해짐에따라 명세를 다시 설계해야하는 경우가 생깁니다.  
  명세를 설계함에따라 개념이 자연스럽게 추가됩니다. (가역)
            
* 유지보수하면서 짜여진 틀 내에서 어떻게는 끼워넣으려하지말고  
  
  틀(구조)을 수정해보세요. 틀은 명세일 수도 있고, 커다란 로직흐름일 수도 있습니다.
  ( 안목이 필요하고, 실행능력이 제일 중요한 것같아요. )
            
#### 인터페이스 생성 방법

* 역할, 책임, 협력으로 식별
* 객체가 수신해야하는 메세지 결정하고 메세지들이 모여 객체의 인터페이스 구성
            
    1. Engine 객체를 DB에 저장해야되네, JSON으로 뽑아내는 기능이 있으면 좋겠다.
    2. 이제 Tire 객체에서도 DB에 저장해야되네, 얘도 JSON으로 뽑아내는 기능이 있으면 좋겠네?
    3. Handle 객체에서도 JSON으로 뽑아내는 기능이 필요하네;;
    4. IJson 인터페이스를 만들어야겠다~
    5. 그리고 DB저장 시, 이 인터페이스를 구현한 클래스만 저장 가능 하도록 구조를 변경해야지~ ( saveJson )

<br/>

## 커피 전문점 도메인

커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현

1. 구성요소 분석하기
    1. 메뉴판 객체
        1. 아메리카노
        2. 카푸치노
        3. 카라멜 마키아또
        4. 에스프레소
    2. 손님 객체
    3. 바리스타 객체
    4. 아메리카노 객체
    5. 카푸치노 객체
    6. 카라멜 마키아또 객체
    7. 에스프레소 객체

2. 객체 간 관계 분석하기
    1. 손님은 메뉴판을 알아야한다.
    2. 손님은 바리스타에게 주문을 해야한다.
    3. 바리스타는 커피를 제조할 수 있어야한다.

3. 타입 분류하기
    1. 손님 타입
    2. 바리스타 타입
        1. 커피 타입
        2. 아메리카노
        3. 카푸치노
        4. 카라멜 마키아또
        5. 에스프레소
    3. 메뉴판 타입
    4. 메뉴 항목 타입

<br/>

## 도메인 모델 - 객체 관계도

<img width="300" alt="07-3" src="https://github.com/ciocio97/today_i_learned/assets/80025242/ed67b391-f46e-4aa1-b5c4-216f7612d178">
<p></p>

* 메뉴판은 메뉴항목 4개를 포함(마름모)하고 있다.
* 메뉴판과 손님은 서로 포함하는 관계는 아니지만, 알고 있어야한다.
* 손님과 바리스타는 서로 포함하는 관계는 아니지만, 알고 있어야한다.
* 바리스타와 커피는 서로 포함하는 관계는 아니지만, 알고 있어야한다. 포함시킬 수도 있겠네요.

<br/>

## 설계하고 구현하기

* 훌륭한 객체를 설계하는 것이아니라 훌륭한 협력을 설계하자.
  * 훌륭한 객체는 훌륭한 협력을 설계하면 자연스럽게 만들어진다.
    
<br/>

#### UML

<img width="300" alt="07-4" src="https://github.com/ciocio97/today_i_learned/assets/80025242/68705851-5646-44bc-9ea5-9965ac86458c">
<p></p>

* 메세지 위에 붙은 화살표는 메세지에 담을 부가 정보
* ex. 커피를 주문하라.( = 메뉴 이름을 달라. )
* 화살표방향이 매우 헷갈리는데, 잘 이해 되나요?
* UML은 표준이 아니다. ( 꼭 지켜야하는 법칙이 아니다. )
  * 의사소통이라는 목적에 부합하다면 용도에 맞게 UML을 수정하고 뒤틀어라.
    
<img width="300" alt="07-5" src="https://github.com/ciocio97/today_i_learned/assets/80025242/7517a651-7206-4f2b-9506-26fa59ec916f">
<img width="300" alt="07-6" src="https://github.com/ciocio97/today_i_learned/assets/80025242/b48e0dcc-2faa-4c4c-8acf-2afc51d0493e">
<p></p>


`프로그래밍 설계에 대해 잘 말해준 것같아요. 시스템 설계나 서비스 설계와는 다른 점인 것같아요.`

* 명세 스케치

```// 제품
interface IProduct { // 제품 별 품질을 정할 수 있다. getTasteScore(): number getSmellScore(): number
}
// 메뉴
interface IMenu { getName(): string getPrice(): number // 기본 레시피를 통해 제품을 만듭니다. makeProduct(): IProduct
}
// 메뉴판
class MenuBoard { private readonly menus: Array<IMenu>; constructor( menus: Array<IMenu> ){ this.menus = menus; } // 메뉴판의 메뉴를 볼 수 있습니다. public getMenus(): Array<IMenu> { return this.menus; }
}
// 돈
interface IMoney { getName(): string getValue(): number
}
// 구매자
interface ICustomer { /* 구매자(구현체) 취향에 따라 내부 구현을 달리할 수 있다. 예) 신명철 - 90%확률로 아메리카노를 먹고, 10%확률로 주문을 안한다. 겨울에는 핫, 여름에는 아이스를 먹는다. 문창희 - 50%확률로 아이스 초코를 먹고, 25% 확률로 아이스 아메리카노를 먹고, 25% 확률로 같이온 사람들이 추천한 메뉴를 먹는다. */ // 메뉴판으로부터 주문을 위한 메뉴를 고릅니다. getMenusToOrder( menuBoard: MenuBoard ): Array<IMenu> /* 구매자에 따라 내부 구현을 달리할 수 있다. 예) 어린이는 돈이 없어서 부모님한테 돈을 얻어 돈을 낼 수 있다. 어른들은 자기 지갑에서 돈을 바로 낸다. */ // 돈을 넣는다. putMoney( money: Array<IMoney> ): void // 돈을 꺼낸다. getMoney( price: number ): Array<IMoney>
}
// 캐셔
interface ICashier { calculate( menus: Array<IMenu>, money: Array<IMoney> ): Array<IMoney>
}
// 바리스타
interface IBarista { // 바리스타(구현체) 능력에 따라 기본 레시피를 이용할 수도 있고, 자체 프로덕트를 생성할 수 있다. makeProduct( menu: IMenu ): IProduct
}
// 구현에 따라 캐셔와 바리스타가 합쳐질 수 있다.
class Barista implements IBarista, ICashier { public calculate( menus: Array<IMenu>, money: Array<IMoney> ): Array<IMoney> { // ... } public makeProduct( menu: IMenu ): IProduct { // ... }
}```

<br/>

## 코드의 세 가지 관점

코드는 세 가지 관점을 모두 제공해야 한다.

#### 개념 관점

* Customer, Menu, MenuItem, Barista, Coffe 클래스가 보인다.
* 커피 제조 방법을 변경해야한다면, 어디를 수정해야할까?
    * 개념 상 커피를 제조하는 Barista를 수정해야함을 쉽게 유추할 수 있다.

#### 명세 관점

* 클래스의 인터페이스 ( = public )
    * public 메서드는 공용 인터페이스므로 수정 시 협력하는 객체 모두에 코드 수정이 생긴다. ( 수정이 힘듬 )
    * public 메서드의 명세를 의마하는 것같아요.
* 탄력적인 인터페이스를 만들 수 있는 능력을 길러라 ( = 추상화 능력 )
* 저자는 왜 언어도 자바인데, 인터페이스에 대한 예제를 실제 인터페이스 코드가 아닌 클래스로만 설명했는지 궁금하네요.

#### 구현 관점

* 내부 구현의 변경은 원칙적으로 외부 객체의 영향을 미쳐서는 안 된다.
* 철저히 캡슐화가 되어야한다.

<img width="600" alt="07-7" src="https://github.com/ciocio97/today_i_learned/assets/80025242/eb7f0ebd-3a71-4df5-a6c9-dddb57d3da55">
<p></p>

* 다른 사람이 여러분의 코드를 읽으면서 세 가지 관점을 쉽게 포착하지 못한다면 세 가지 관점이 명확하게 드러날 수 있게 코드를 개선하라.
    * 세 가지가 잘보여야 누가봐도 잘짜여진 코드이고, 유지보수가 쉬워요.

#### 도메인 개념을 참조하는 이유

* 메세지를 수신할 객체를 어떻게 선택할까?
    * 도메인 개념 중에서 적절한 것을 선택하기
        * 도메인 개념에서 선택 시, 의미를 쉽게 유추할 수 있다.
            * 개념이 쉽게 변형되지 않으니 보수가 적어진다.
* ( 저번장에도 나온 내용이네요. )

#### 인터페이스와 구현을 분리하라

> 명세 관점과 구현 관점이 뒤섞여 여러분의 머리속을 함부로 어지럽히지 못하게 하라.

* 개념 관점과 명세 관점 사이는 그렇게 중요하지 않은 경우가 많다.
    * 왜 그럴까요?
* 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 쉽게 요동친다.
* 구현 관점을 가장 빈번하게 사용하지만,  
  훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다.
    
* 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다는 사실을 기억하라.

##### 요약

* 클래스를 봤을 때, 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다.
* 캠슐화를 위반해서 구현을 인터페이스를 밖에 노출하면 안된다.
* 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어놓아서도 안 된다.
* 결국 세 가지 관점 모두에서 클래스를 바라볼 수 있으려면 훌륭한 설계가 필요하다.
