## 기능 설계 VS 구조 설계

| 기능 설계 | 구조 설계 |
| --- | --- |
| 제품이 사용자를 위해 무엇을 할 수 있는가 | 제품의 형태가 어떠해야 하는가 |

* 소프트웨어를 개발하는 이유는 사용자에게 필요한 기능을 제공하기 위함.  
  ⇒ 사용자가 무엇을 원하는지, 사용자의 요구를 만족시키기 위해 어떤 기능을 제공해야 하는지 고민함.
* 성공적인 소프트웨어가 지닌 공통적 특징은 훌륭한 기능을 제공하는 동시에 사용자가 원하는 새로운 기능을 빠르고 안정적으로 추가할 수 있다는 것.  
  ⇒ 깔끔하고 단순하며 유지보수하기 쉬운 설계가 필요함.
* 훌륭한 설계자는 사용자가 만족할 수 있는 훌륭한 기능을 제공하는 동시에  
  예측 불가능한 요구사항 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공하는 능력을 갖춰야 함.
* 예측 불가능한 요구사항 변경에 대비하는 최선책은 변경을 예측하는 것이 아니라,  
  변경을 수용할 수 있는 선택의 여지를 설계에 마련해 두는 것.
* 객체지향 접근방법은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템 기능을 객체 간의 책임으로 분배함.  
즉, 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 함.
* 안정적인 객체 구조는 변경을 수용할 수 있는 유연한 소프트웨어를 만들 수 있는 기반을 제공함.

<br/>

## 두 가지 재료: 기능과 구조

#### 기능 — 길 물어보기

* 사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템의 서비스.
* 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현됨.

#### 구조 — 지도

* 시스템의 기능을 구현하기 위한 기반으로, 기능 변경을 수용할 수 있도록 안정적이어야 함.
* 사용자나 이해관계자들이 도메인에 대해 생각하는 개념과 개념들 간의 관계로 표현됨.

<br/>

## 안정적인 재료: 구조

#### 도메인 모델(domain model)

* 도메인(domain)

  * 사용자가 프로그램을 사용하는 대상 분야  
    e.g) 사용자가 원하는 공간에 인테리어 3D 시뮬레이션을 하는 것
  * 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태.
  * 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화함.
  * 소프트웨어 사용자들은 도메인에 존재하는 현상을 이해하고 현상에 반응하기 위해 도메인과 관련된 멘탈 모델을 형성함.

* 멘탈 모델(mental model)

  * 사용자 모델 : 사용자가 제품에 대해 갖고 있는 개념들의 모습
  * 디자인 모델 : 설계자가 마음 속에 갖고 있는 시스템에 대한 개념화
  * 시스템 이미지 : 최종 제품
  * 설계자는 디자인 모델을 기반으로 만든 시스템 이미지가 사용자 모델을 정확하게 반영하도록 노력해야 함.

<br/>

<img width="600" alt="06-1" src="https://github.com/ciocio97/today_i_learned/assets/80025242/03727af7-b3a5-4a3d-aea4-2c2fc7427329">
<p></p>
<br/>

cf. **데이터 모델(data model)**

* 데이터의 관계, 접근과 그 흐름에 필요한 처리 과정이 추상화된 모형.
* 추상화 수준에 따라 개념적 데이터 모델, 논리적 데이터 모델, 물리적 모델로 구분됨.
* 계층형 데이터 모델, 관계형 데이터 모델, 네트워크형 데이터 모델, 객체 지향형 데이터 모델 등이 있음.

<br/>

#### 도메인과 객체지향

* 애플리케이션은 도메인 모델을 기반으로 설계되어야 함.  
  *why?*
  도메인 모델이란 사용자들이 도메인을 바라보는 관점이며,
  설계자가 시스템의 구조를 바라보는 관점인 동시에 소프트웨어 안에 구현된 코드의 모습 그 자체.

* 객체지향 
    * 도메인 모델의 세 가지 측면을 모두 모델링할 수 있는 패러다임
    * 사용자들이 이해하고 있는 도메인의 구조와 최대한 유사하게 코드를 구조화할 수 있음.
    * `사용자의 관점(=사용자 모델)`, `설계자의 관점(=디자인 모델)`, `코드의 모습(=시스템 이미지)`  
      을 모두 유사한 형태로 유지할 수 있게 하는 유용한 사고 도구와 프로그래밍 기법을 제공함.  
      ⇒ 연결완전성, 표현적 차이

* 표현적 차이
    * 소프트웨어 객체는 현실 객체를 완전히 모방하는 것이 아니라 `은유`를 기반으로 재창조된 것.
    * 소프트웨어 객체와 현실 객체 사이에는 `표현적 차이` 또는 `의미적 차이`가 존재함.  
      ⇒ 은유를 통해 둘 사이의 간극을 최대한 줄여나가는 것이 핵심.
    * 소프트웨어 객체는 그 대상의 현실성과 관계 없이 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 함.
    * 도메인 모델을 기반으로 설계하고 구현하면 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있어 결과적으로 표현적 차이가 줄어듦.
  
* 불안정한 기능을 담는 안정적인 도메인 모델
    * 도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것.  
      ⇒ 사용자들은 누구보다도 도메인의 본질적인 측면을 가장 잘 이해하고 있음.
    * 사용자 모델에 포함된 개념과 규칙은 비교적 변경될 여지가 적기 때문에 사용자 모델을 기반으로 설계와 코드를 만들면 상대적으로 안정적인 구조를 가질 수 있음.
    * 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있음.

<br/>

## 불안정적인 재료: 기능

#### 유스케이스 모델(usecase model)

* 유스케이스(usecase)

  * 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이루어지는 상호작용의 흐름을 텍스트로 정리한 것.  
    e.g ) 지도에서 아파트 도면을 찾아 스타일링

  * 유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점에 있음.

  * 유스케이스의 특성
      * 사용자와 시스템 간의 상호작용을 보여주는 텍스트로, 핵심은 사용자와 시스템 간의 상호작용을 일련의 이야기 흐름으로 표현하는 것.
      * 하나의 시나리오가 아닌 여러 시나리오들의 집합. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로를 의미함.  
        e.g ) 직접 도면을 찾아 스타일링 → 다른 사용자의 스타일링 이어꾸미기
      * 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 피처(feature) 목록과 다름.  
        ⇒ 단순히 기능을 나열하는 것이 아니라 이야기를 통해 연관된 기능들을 함께 묶을 수 있음.  
        e.g ) 도면으로 스타일링  
            1 ) 지도에서 도면을 찾아 스타일링  
            2 ) 라이브스케치로 직접 도면을 그려서 스타일링
      * 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춤.  
        ⇒ 본질적인 유스케이스
      * 내부 설계와 관련된 정보를 포함하지 않음.  
        ⇒ 단지 사용자가 시스템을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있는가에 대한 정보만 담김.

<br/>
<img width="600" alt="06-2" src="https://github.com/ciocio97/today_i_learned/assets/80025242/8ef6926d-6326-4293-a427-dc2c0fd9dd02">
<p></p>

<br/>

## 재료 합치기 : 기능과 구조의 통합

* 도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 일반적으로 사용되는 도구라고 할 수 있음.

* 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 `책임` 으로 분배해야 함.

* 객체지향 패러다임
    * 프로그래머 관점 : 시스템은 사용자로부터 전송된 메시지를 수행하기 위해 책임을 수행하는 거대한 자율적인 객체
    * 사용자 관점 : 시스템은 자신이 전송한 메시지에 응답하는데 필요한 책임을 수행하는 객체

* 책임-주도 설계
    * 시스템에 할당된 커다란 책임은 시스템 안의 작은 규모의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화될 수 있음.
    * 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택하여 표현적 차이를 줄임.  
      → 협력을 완성하는데 필요한 메시지를 식별하면서 객체들에게 책임을 할당함.  
      → 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함께 메서드를 구현함.
    * 유스케이스로부터 메시지와 사용자가 달성하려는 목표를,  
      도메인 모델로부터 기능을 수용할 수 있는 안정적인 구조를 제공받아 실제로 동작하는 객체들의 협력 공동체를 창조함.
    * 견고한 객체지향 애플리케이션을 개발하기 위해서는 사용자의 관점에서 시스템의 기능을 명시하고,  
      사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 함.
    * 유스케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 ‘재귀적 합성’이라는 객체지향의 기본 개념을 보여줌.  
      ⇒ 객체에 대한 재귀는 객체지향의 개념을 모든 추상화 수준에서 적용 가능하게 하는 동시에 객체지향 패러다임을 어떤 곳에서든 일관성 있게 적용할 수 있게 함.
      
* 기능 변경을 흡수하는 안정적인 구조
    * 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현할 경우,  
      시스템의 기능이 변경되더라도 비즈니스의 핵심 정책이나 규칙이 변경되지 않는 한 전체적인 구조가 안정적으로 유지됨.  
      ⇒ 기능의 변경에 좀 더 유연한 객체지향 패러다임
    * 객체지향은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일함.
        * 모델에서 코드로의 매끄러운 흐름 ⇒ 연결완전성
        * 코드에서 모델로의 매끄러운 흐름 ⇒ 가역성(연결완전성의 역방향)

<br/>

💡 도메인 모델의 목표는 사람들이 동일한 용어와 개념을 이용해 의사소통하고, 코드로부터 도메인 모델을 유추할 수 있게 하는 것!

<br/>

cf. **도메인 주도 설계(Domain Driven Design)**

* 도메인을 중심으로 소프트웨어를 모델링하는 설계 접근 방식.
* 소프트웨어 코드의 구조와 비즈니스 도메인이 일치하도록 함.

<br/>
<img width="600" alt="06-3" src="https://github.com/ciocio97/today_i_learned/assets/80025242/dcde501a-de94-43f9-8b68-02223572f238">
<p></p>
<br/>

### ref

[소프트웨어 개발방법론](http://www.kocw.net/home/cview.do?mty=p&kemId=1007144)
