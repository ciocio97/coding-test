## 추상화 기법

* 도메인에 존재하는 개념들을 **구조화**, **단순화** 하기 위해 다양한 추상화 기법을 사용
* 객체지향 패러다임에서 사용하는 추상화 기법의 예 : 특성을 공유하는 객체들을 동일한 타입으로 분류하는 것

<br/>

## 추상화 기법의 종류

|  |  |
| --- | --- |
| 분류와 인스턴스화 | 분류 : 객체의 구체적인 세부 사항을 숨기고, 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
인스턴스화 : 역으로 범주로부터 객체를 생성하는 과정 |
| 일반화와 특수화 | 일반화 : 범주 사이의 차이를 숨기고, 범주 간에 공유하는 공통적인 특성을 강조
특수화 : 일반화의 역 |
| 집합과 분해 | 집합 : 부분과 관련된 세부 사항을 숨기고, 부분을 사용해서 전체를 형성하는 과정
분해 : 집합의 반대 과정으로 전체를 부분으로 분리 |

<img width="600" alt="08-1" src="https://github.com/ciocio97/today_i_learned/assets/80025242/59d4c682-efca-4a49-8975-03e5465f5cd8">
<p></p>

## 1 ) 분류와 인스턴스화

#### 개념과 범주

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것

개념 : 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어

* 자동차 범주 → 바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단
* 나무 범주 → 푸른 잎과 갈색의 줄기를 가진 다년생 식물

분류 : 세상에 존재하는 객체에 개념을 적용하는 과정,

<br/>

객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킴

<img width="600" alt="08-2" src="https://github.com/ciocio97/today_i_learned/assets/80025242/8aedbf44-9e99-4ee6-80f9-284c4a900fb0">
<p></p>

다른 것들과 여러가지 자동차 객체들을 분류하여 자동차라는 개념을 떠올리며 자동차 집합에 범주화

`개념` : 수많은 개별적인 현상들  
`타입` : 하나의 개념  
`객체` : 타입의 인스턴스

분류 => 객체와 타입 간의 관계를 나타내게 됨

<br/>

#### 타입

타입을 객체의 분류 장치로서 적용할 수 있으려면 세 가지 관점의 정의가 필요

1. 심볼 symbol : 타입을 가리키는 간략한 이름이나 명칭
2. 내연 intension : 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있음
3. 외연 extension : 타입에 속하는 모든 객체들의 집합

<br/>

#### 외연과 집합

타입의 외연은 타입에 속하는 객체들의 집합으로 표현

* 단일 분류(single classification) : 한 객체가 한 시점에 하나의 타입에 속하는 것
* 다중 분류(multiple classification) : 한 객체가 한 시점에 여러 분류에 속할 경우

객체지향 프로그래밍 언어들은 단일 분류만 지원!  
한 객체는 오직 한 클래스의 인스턴스여야만 함(두 개의 클래스 인스턴스 일 수 없음)

* cf ) 다중 상속 : 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용(타입의 정의를 생략할 순 없음)
* cf ) 다중 분류 : 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용
* 동적 분류(dynamic classification) : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
* 정적 분류(static classification) : 객체가 자신의 타입을 변경할 수 없는 경우

→ 클래스 기반의 객체지향 언어들에선 타입은 클래스를 이용하여 구현  
→ 클래스로 부터 인스턴스를 생성한 후 클래스를 변경 할 수 있는 방법이 없음  
→ 즉, 객체의 타입을 변경 할 수 없다!!!

(디자인 템플릿을 이용여 가능하지만,  
단순함을 위해서 항상 다중분류와 동적 분류 보다는 단일 분류와 정적 분류를 사용하자)

<br/>

#### 클래스

객체지향 프로그래밍 언어를 이용해 **타입을 구현**할 때 클래스를 사용  
이외에도 **코드를 재사용하는 용도**로도 쓰임  
인스턴스를 생성할 수 없는 **추상 클래스**나 **인터페이스**를 이용해 타입을 구현할 수도 있음

객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의됨

→ 자바스크립트처럼 클래스가 존재하지 않는 프로토타입 기반의 언어는  
아리스토텔레스의 객관적인 분류 체계가 존재한다는 사상에 대해 철학적 의문을 갖는 것에 그 뿌리를 두고 있음  
→ 클래스가 없는 프로토타입 언어에서는 분류와 인스턴스화는 **프로토타입** 이라는 객체의 복사를 통해 이뤄짐

<br/>

## 2 ) 일반화와 특수화

#### 범주의 계층

린네의 분류 체계에 따라 범주 간의 계층적인 구조를 가지게됨  
세부적인 범주가 계층의 하위에 위치하고, 좀 더 일반적인 범주가 계층의 상위에 위치함  
상위에 위치한 범주를 계층의 하위에 위한 범주의 **일반화**  
계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 **특수화**

<br/>

#### 서브타입

* 슈퍼타입(supertype) : 다른 타입보다 좀더 일반적인 타입 (서브타입의 일반화)
* 서브타입(subtype) : 다른 타입보다 좀 더 특수한 타입(슈퍼타입의 특수화, 수퍼타입의 특성 공유)
* 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 100% 규칙과 is-a 규칙을 만족 시켜야 함
  * 100% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 함, 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야함
  * is-a 규칙 : 서브타입의 인스턴스는 슈퍼타입 집합에 포함되어야 한다. [subtype] is a [supertype] 으로 테스트

<br/>

#### 상속

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응(conformance)해야 함  
특정 기대 집합에 대해 서브 타입의 슈퍼타입에 대한 대체 가능성을 의미

* 구조적인 순응(structural conformance) : 기대 집합은 **속성**과 **연관관계**에 관한 것
  * Person(name) → 서브타입인 Employee (name)
  * Employee 는 Person에 대해 구조적으로 순응하며 Person을 대체 할 수 있음
* 행위적인 순응(behavioral conformance) : 기대집합은 **행위가 동일한 계약을 기반으로 하느냐**에 관한 것
  * 타입의 행위
  * 서브타입은 행위적으로 슈퍼타입으 ㄹ대체 가능
  * Person(getAge()) → 서브타입 Employee(getAge())

상속의 또다른 용도는 코드 중복을 방지하고, 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공  
한 클래스가 다른 클래스를 상속한다면 상속하는 타입은 부모 클래스의 데이터와 메소드를 사용, 수정, 확장 할 수 있음

* 서브타이핑(subtyping) : 서브클래스가 슈퍼클래스를 **대체할 수 있는 경우**, 인터페이스 상속(interface inheritance)
* 서브클래싱(subclassing) : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 & 코드만 공유, 구현 상속(implementation inheritance)
* 클래스간의 위임(delegation) : 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법
  * 각 클래스의 부모 클래스로 메시지를 위임하여, 계층 내 어떤 클래스가 메시지를 처리하거나, 최상위 부모 클래스에 위임될 때까지 계속 위임함
* 프로타입 기반의 언어에서 상속는 객체와 객체 간의 관계로 이루어짐
  * 위임 또 한 객체에서 객체 간으로 이뤄짐

<br/>

## 3 ) 집합과 분해

#### 계층적인 복잡성

* 집합 : 안정적인 형태의 부분으로부터 전체를 구축하는 행위
  * 많은 수의 사물들의 형상을 하나의 단위로 다룸으로써 복잡성을 줄일 수 있음
  * 불필요한 세부사항을 추상화
* 분해 : 전체를 부분으로 분할하는 행위
  * 필요한 시점에는 전체를 분해 함으로써 그 안에 포함 된 부분들을 새로운 전체로 다룰 수 있음  
    → 전체와 부분 간의 일관된 계층구조는 재귀적인 설계를 가능하게 함  
    → 집합은 전체의 내부로 불필요한 세부사항을 감춰주기 때문에 **추상화** 메커니즘 & **캡슐화** 메커니즘

<br/>

#### 합성 관계

<img width="600" alt="08-3" src="https://github.com/ciocio97/today_i_learned/assets/80025242/c3496d4d-7f37-4113-82db-89a07b408a0b">
<p></p>

* 합성관계는 부분을 전체 안에 캡슐화 함으로써 인지 과부하를 방지
* 모델을 다루는 사람은 주문 항목과 관련된 세부사항은 무시하고 **주문** 과 **상품** 만이 존재하는 것 처럼 모델을 다룰 수 있음
* 필요하다면 주문 내부로 들어가 주문 항목과 관련된 세부사항을 확인할 수 있음
* 합성관계를 이용해 계층적인 객체들의 그룹을 만들면 관련된 복잡성이 완화될 수 있음

<img width="600" alt="08-4" src="https://github.com/ciocio97/today_i_learned/assets/80025242/b0e89484-d294-4869-a594-95d82b35abb5">
<p></p>

* 상품과 주문 항목 사이에는 관계가 존재하긴 하지만, 상품은 주문 항목의 일부가 아님
* **합성 관계** :주문과 주문 항목은 전체와 부문 간의 관계를 나타내는 관계
  * 객체가 제거될 때 내부의 포함된 객체도 함께 제거
  * 주문이 제거되면 주문 항목도 함께 제거
* **연관 관계 :** 주문 항목과 상품 간에는 단순한 물리적 통로가 존재한다는 사실만 나타내는데 관계
  * 연관관계로 연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않음
  * 주문의 제거로 인해 주문 항목이 제거 되더라도 상품은 계속 존재

<br/>

#### 패키지

<img width="600" alt="08-5" src="https://github.com/ciocio97/today_i_learned/assets/80025242/a6760449-986a-44d3-ad76-02d71d534034">
<p></p>

소프트웨어에는 물리적인 형체라는 것이 존재하지 않으므로 구조를 단순화 하기 위해서는 서로 관련성이 높은 클래스집합을논리적인 단위로 통합해야 함

* 패키지(package) 또는 모듈(module) : 소프트 웨어의 전체적인 구조를 표현하기위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소
* 시스템의 전체적인 구조를 이해하기 위해 한번에 고려해야하는 요소의 수를 줄일 수 있음
* 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있음
* 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화