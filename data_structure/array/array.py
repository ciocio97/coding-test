'''

0️⃣ 배열 개념

: 인덱스와 값을 일대일 대응해 관리하는 자료구조.
: 찾고 싶은 값(데이터)의 인덱스만 알고 있다면 빠르게 탐색 가능. → random access(임의 접근)

Python 의 경우 배열을 지원하는 문법 없음. 대신 '리스트' 문법 지원.
→ 파이썬의 '리스트' 는 동적으로 크기 조절이 가능함.

배열은 2차원 배열, 3차원 배열과 같이 다차원 배열을 사용할 때도 많음.
그러나 컴퓨터 메모리 구조는 1차원이므로, 배열의 차원과 무관하게 메모리에 연속 할당함.
배열의 각 데이터는 메모리의 낮은 주소에서 높은 주소 방향으로 연이어 할당됌.

'''

# 1차원 배열 선언

arr = [0, 0, 0, 0, 0, 0]
arr = [0] * 6
arr = list(range(6))            # 리스트 생성자 [0, 1, 2, 3, 4, 5]
arr = [0 for _ in range(6)]     # 리스트 컴프리헨션 [0, 0, 0, 0, 0, 0]

# 2차원 배열 선언

arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
arr = [[i]*4 for i in range(3)] # 크기가 3 * 4 리스트 선언
                                # 리스트 컴프리헨션 [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]]


'''

1️⃣ 배열의 효율성

배열은 random access(임의 접근) 방법으로 모든 위치에 있는 데이터에 단 한번에 접근 가능하므로,
데이터에 접근하기 위한 시간 복잡도는 O(1).
데이터를 '어디에' 저장하느냐에 따라 추가 연산에 대한 시간 복잡도가 달라짐.

- 맨 뒤에 삽입할 경우 : O(1) → 기존 데이터 위치에 영향을 주지 않음.
- 맨 앞에 삽입할 경우 : O(N) → 기존 데이터를 한 칸씩 미는 연산이 필요.
- 중간에 삽입할 경우  : O(N) → 중간 이후의 기존 데이터를 한칸씩 미는 연산이 필요.

→ 데이터 추가/삭제에 드는 비용이 큼.

📌 배열을 선택할 때 고려할 점

1. 할당할 수 있는 메모리 크기 확인하기.
데이터에 자주 접근하거나 읽어야 하는 경우 배열을 사용하는 것이 좋지만,
메모리 공간을 충분히 확보해야한다는 단점도 있다.
보통 정수형 1차원 배열은 1000만개 / 2차원 배열은 3000 * 3000 크기 최대.
(Python 에서 리스트를 사용해 배열을 구현하기로 했기때문에, 배열 크기에 대한 고민은 하지 않음)

2. 중간에 데이터 삽입이 많은지 확인하기.
배열은 선형 자료구조이므로, 중간이나 처음에 데이터를 빈번하게 삽입하면
시간 복잡도가 높아져 시간 초과 발생 가능.

'''


'''

2️⃣ 자주 사용하는 리스트 기법

'''

# [추가] append() 메서드 (배열 맨 끝)
my_list = [1, 2, 3]
my_list.append(4)                      # [1, 2, 3, 4]

# [추가] + 연산자 (배열 맨 끝)
my_list = [1, 2, 3]
my_list = my_list + [4, 5]             # [1, 2, 3, 4, 5]

# [추가] insert() 메서드 (특정 위치)
my_list = [1, 2, 3, 4, 5]
my_list.insert(2, 123)                 # [1, 2, 123, 3, 4, 5]


# [삭제] pop() 메서드 (특정 위치)
my_list = [1, 2, 3, 4, 5]
popped_element = my_list.pop()         # 3
print(my_list)                         # [1, 2, 4, 5]

# [삭제] remove() 메서드 (특정 데이터)
# → 인수로 받은 값이 처음으로 등장하는 위치의 데이터 제거
my_list = [1, 2, 3, 2, 4, 5]
my_list.remove(2)                      # [1, 3, 2, 4, 5]


# 리스트 컴프리헨션
# : 기존 리스트를 기반해 새 리스트를 만들거나 반복문, 조건문을 이용해 복잡한 리스트를 생성하는 문법
# : 기존 리스트를 변경하지 않음
numbers = [1, 2, 3, 4, 5]
squares = [num**2 for num in numbers]  # [1, 4, 9, 16, 25]


'''

3️⃣ 리스트 연관 메서드

'''

fruits = ['apple', 'banana', 'cherry', 'apple', 'orange', 'banana', 'kiwi']

# len() 함수
# : 리스트 전체 개수를 반환
len(fruits)                  # 7

# index() 메서드
# : 특정 데이터가 처음 등장한 인덱스를 반환. 없으면 -1 반환
fruits.index('banana')       # 1

# sort() 메서드
# : O(NlogN)
# : 사용자가 정한 기준에 따라 리스트 데이터를 정렬. 기존 리스트 변경 ⭕️
fruits.sort()                # ['apple', 'apple', 'banana', 'banana', 'cherry', 'kiwi', 'orange']
fruits.sort(reverse=True)    # ['orange', 'kiwi', 'cherry', 'banana', 'banana', 'apple', 'apple']

# count() 메서드
# : 특정 데이터의 개수를 반환
fruits.count('apple')        # 2


'''

📌 내장 함수

'''

# set() 함수
# : O(N) → 해시 알고리즘
# : 집합을 생성하여 반환. (집합은 중복값을 허용하지 않음)
set(fruits)                  # {'kiwi', 'cherry', 'banana', 'apple', 'orange'}
list(set(fruits))            # ['kiwi', 'cherry', 'apple', 'orange', 'banana']