<현행 시스템 분석>
    01 구성/기능/인터페이스 파악
    02 아키텍쳐 및 소프트웨어 구성 파악
    03 하드웨어 및 네트워크 구성 파악

    --소프트웨어 아키텍쳐?
        --소프트웨어의 구성 요소들 사이에서 유기적 관계를 표현하고, 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙

        --소프트웨어 아키텍쳐 프레임워크?
            --소프트웨어 집약적인 시스템에서 아키텍쳐가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍쳐 기술 표준

                --아키텍쳐 명세서
                --이해관계자
                --관심사
                --관점
                --뷰
                --근거
                --목표
                --환경
                --시스템
        
        --소프트웨어 아키텍쳐 4+1 뷰?
            --고객의 요구 사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
            --4개의 분리된 구조로 구성되는 아키텍쳐 개념을 제시하고, 이들 4개 구조가 서로 충돌되지는 않는지,
              시스템의 요구사항을 충족시키는 지를 증명하기 위해 '유스케이스'를 사용한다

                --유스케이스 뷰: 아키텍쳐를 도출하고 설계하며, 다른 뷰를 검증하는 데 사용되는 뷰
                                사용자, 설계자, 개발자, 테스트 관점
                --논리 뷰: 시스템의 '기능적'인 요구사항이 어떻게 제공되는 지 설명해주는 뷰
                           설계자, 개발자 관점
                --프로세스 뷰: 시스템의 '비기능적'인 속성으로, 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
                               개발자, 시스템 통합자 관점
                --구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
                --배포 뷰: 컴포넌트가 물리적인 아키텍쳐에 어떻게 배치되는가를 매핑해서 보여주는 뷰

        --소프트웨어 아키텍쳐 패턴?
            --소프트웨어를 설계할 때 참조할 수 있던 전형적인 해결 방식

                --계층화 패턴: 
                --클라이언트-서버 패턴:
                --파이프-필터 패턴: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능
                                   서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정이 반복되는 패턴 
                --브로커 패턴: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용됨. 이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴
                              서버는 자신의 기능들을 브로커에 넘겨주며(Publish), 
                              클라이언트가 브로커에 서비스를 요청하면 브로커는 자신의 레지스트리에 있는 적합한 서비스를 건내줌(Redirection).
                --모델-뷰 컨트롤러 패턴: 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴
                                        MVC패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행할 수 있음
                                        --모델: 핵심 기능과 데이터를 보관
                                        --뷰: 사용자에게 정보를 표시함
                                        --컨트롤러: 사용자로부터 입력을 받아 처리

                
        --소프트웨어 아키텍쳐 비용 평가 모델
            --아키텍쳐 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍쳐의 적합성을 평가하는 모델

                --SAAM: 경험이 없는 조직에서도 활용가능한 비용 평가 모델
                --ATAM: SAAM을 계승하여 발전함. 아키텍쳐 품질 속성을 만족시키는지, 속성들의 이해 상충 관계까지 평가하는 모델
                --CBAM: ATAM 바탕으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
                --ADR:  소프트웨어 아키텍쳐 구성 요소 간 '응집도'를 평가하는 모델 
                --ARID: 전체 아키텍쳐가 아닌, '특정 부분에 대한 품질 요소'에 집중하는 비용 평가 모델

    --디자인 패턴?
        --소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
        --디자인 패턴을 참고하여 개발할 경우, 개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화에 도움이 됨

            --생성 패턴
                --Builder: 복잡한 인스턴스를 조립하여 만드는 구조 / 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에도 다른 결과를 만들 수 있음
                --Prototype: 원본 객체를 복제함으로써 객체를 생성
                --Factory Method: 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식 !
                --Abstract Factory: 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관된 객체들을 그룹으로 생성하여 추상적으로 표현함
                --Singleton: 생성된 객체를 어디서든 참조할 수는 있지만, 여러 프로세스가 동시에 참조할 수는 없음

            --구조 패턴
                --Bridge: 기능의 클래스 계층과 구현의 클래스 계층을 연결함
                --Decorator: 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식
                --Facade: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용하게끔 하는 패턴
                --Flyweight: 인스턴스가 필요할 때마다 매번 생성하지 않고, 가능한 ! 공유해서 사용함으로써 메모리를 절약하는 패턴
                --Proxy: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
                --Composite: 객체들의 관계를 트리 구조로 구성하여, 부분-전체 계층을 표현하는 패턴으로, 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
                --Adapter: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
        
            --행위 패턴
                --Mediator: 수많은 객체들 간의 복잡한 상호작용을 해결하기 위해 이를 통제하고 지시할 수 있는 중재자를 두는 패턴. 객체 사이의 의존성을 줄여 결합도를 낮춰줌
                --Interpreter: 언어에 문법 표현을 정의하는 패턴. SQL이나 통신 프로토콜을 개발할 때 사용
                --Iterator: 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴. 내부 표현 방법의 노출없이 순차적인 접근 가능
                --Template Method: 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴. 코드의 양이 줄면서 유지 보수가 용이해지는 장점이 있음
                --Observer: 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
                --State: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
                --Visitor: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴. 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행함
                --Command: 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
                --Strategy: 알고리즘을 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴. 행위 객체를 클래스로 캡슐화해 동적으로 행위를 변환
                --Memento: 특정 시점의 객체 내부 상태를 객체화함. 요청에 따라 객체를 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴
                --Chain of Responsibility: 요청을 처리할 수 있는 객체가 둘 이상 존재하여, 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
                
--OMT: 모든 소프트웨어 구성 요소를 '그래픽 표기법'을 이용하여 모델링하는 '객체 모델링' 기법
    --럼바우(Rumbaugh)분석 기법: 객/동/기
        --객체 모델링: (객체 다이어그램) 정보 모델링. 시스템의 정적 구조 표현.
                      시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별, 객체들 간의 관계를 규정하고 객체 다이어그램으로 표시
        --동적 모델링: (상태 다이어그램) 객체들 간의 제어 흐름, 상호 반응 표현
                      상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현
        --기능 모델링: (자료 흐름도) 데이터 값의 변화 과정 표현
                      자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐음을 중심으로 처리 과정을 표현

--HIPO(Hierarchy Input Process Output): 시스템의 분석 및 설계, 문서화할 때 사용되는 기법.  (가총세)
                                        시스템 실행과정인 입력, 처리, 출력 기능을 나타내는 도구.
                                            --01 가시적 도표: 시스템의 전체적인 기능과 흐름을 보여줌
                                            --02 총체적 도표: 입력, 처리, 출력에 대한 정보를 제공함. 프로그램을 구성하는 기능을 기술
                                            --03 세부적 도표: 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히~ 기술하는 도표

--구조적 개발 방법론
    --전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 '분할 & 정복' 접근 방식의 방법론
    --정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법
    --프로세스 중심 / 하향식 방법론
        --나씨-슈나이더만 차트 사용
        --자료흐름도, 자료사전, 소단위 명세서(Mini-Spec)
        --소단위 명세서 : 데이터흐름도 처리항목을 1~2p 소규모 분량으로 요약하여 작성한 논리적 명세서

--컴포넌트 기반 방법론 (CBD)
    --컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론

--애자일 방법론 (Agile Development)
    --절차보다는 사람 중심
    --변화에 유연함 / 신속하게 적응함 / 효율적으로 시스템을 개발 / 신속 적응적 경량 개발 방법론
    --XP, 린(Lean), 스크럼(SCRUM)

        --스크럼
            --백로그: 제품과 프로젝트에 대한 요구사항
            --스프린트: 2~4주의 짧은 개발 기간의 반복적인 수행으로 개발 품질을 향상한다
            --스크럼 미팅: 매일 15분 정도의 미팅으로 To-Do List 계획을 수립한다
            --스크럼 마스터: 프로젝트 리더, 스크럼 수행 시 문제를 인지 및 해결하는 사람
            --스프린트 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록한다
            --번 다운 차트: 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트

*개발 기술 환경*

    --운영 체제?
        --컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해줌
        --컴퓨터 사용자와 하드웨어 간의 인터페이스를 담당하는 프로그램

            --PC
                --윈도즈(Windows): Microsoft 중/소규모 서버, 일반 PC 유지, 관리 비용 장점
                --유닉스(UNIX): IBM, HP, SUN  대용량 처리, 안정성 높은 기업형 서버
                    --리눅스(Linux): Linus Torvalds 중/대규모 서버, 높은 보안성 제공

            --모바일
                --안드로이드(Android): 리눅스 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어,
                                      사용자 인터페이스, 표준 응용 프로그램(웹 브라우저, SMS, MMS)등을 포함하고 있는 소프트웨어 스택 / 리눅스 모바일 운영 체제
                                      개발자들이 자바, 코틀린 언어로 응용 프로그램을 작성할 수 있게 함
                                      컴파일 된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영 체제
                --iOS: 스마트폰, 태블릿 PC의 높은 보안성과 고성능 제공

    --네트워크?
        --컴퓨터 장치들의 데이터 링크를 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
        --데이터 링크들은 유선 매체(광케이블) 또는 무선 매체(Wi-Fi)를 통해 확립된다.

            --OSI 7계층
                --응용 계층 Application
                --표현 계층 Presentation
                --세션 계층 Session
                --전송 계층 Transport
                --네트워크 계층 Network
                --데이터 링크 계층 Data Link 
                --물리 계층 Physical

    --DBMS?
        --데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램

    --미들웨어?
        --분산 컴퓨팅 환경에서 응용 프로그램과 응용 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어
        --운영 체제와 소프트웨어 애플리케이션 사이에 위치하고 있음
        --대표적인 미들웨어로는 WAS가 있음